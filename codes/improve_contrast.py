# -*- coding: utf-8 -*-
"""Improve contrast.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RAJu_sQq5dxjnSJ60YMFcQPWLYSx6sMA
"""

!apt-get -qq install -y libsm6 libxext6 && pip install -q -U opencv-python
import cv2
from PIL import Image
from google.colab.patches import cv2_imshow

import numpy as np
import pandas as pd
import cv2

he1 = cv2.imread("he1.jpg")
he2 = cv2.imread("he2.jpg")
he3 = cv2.imread("he3.jpg")
he4 = cv2.imread("he4.jpg")
def hiseq(he1):
  
  # preprocessing

  he1_gray = cv2.cvtColor(he1, cv2.COLOR_BGR2GRAY)
  unique, counts = np.unique(he1_gray, return_counts=True)
  
# count of each pixel 
  dict_he1 =dict(zip(unique, counts))

# sum of all pixels
  sum_he1 = sum(dict_he1.values())

# preprocessing
  if dict_he1.get(0)==None:
    dict_he1[0]=0

# count of each pixel / sum of all pixels
  for i in dict_he1 :
      dict_he1[i] = dict_he1[i] / sum_he1
   
  dict_accum = {}
  dict_accum[0] = dict_he1.get(0)
 
# cumulative sum 
  for i in range(1,256):
    if dict_he1.get(i):
      dict_accum[i] =  dict_he1.get(i) + dict_accum.get(i-1)
    else:
      dict_accum[i]= dict_accum.get(i-1)

# cumulative sum * max of pixels range
  for i in range(256):
      dict_accum[i] = round(dict_accum.get(i)*255)

#  equalize image
  for i in range(he1_gray.shape[0]):
    for j in range(he1_gray.shape[1]):
       he1_gray[i][j] = dict_accum[he1_gray[i][j]]
  # cv2_imshow(he1_gray)
  return he1_gray

hiseq(he1)  
hiseq(he2) 
hiseq(he3) 
hiseq(he4)

# preprocessing
f_rgb = cv2.imread("he4.jpg")
f = cv2.cvtColor(f_rgb,cv2.COLOR_BGR2GRAY)

f_he = hiseq(f_rgb)

# apply equation
for i in np.arange(0.1,0.6,0.1):
  g = i*f+(1-i)*f_he
  cv2_imshow(g)

def LHE(he1,xWin,yWin):
  
  # preprocessing

  he1_gray = cv2.cvtColor(he1, cv2.COLOR_BGR2GRAY)
  he1_local= np.empty((xWin, yWin), float)

  # for m in range(0,he1_gray.shape[0]-xWin,int((xWin-1)/2)):
  #   for n in range(0,he1_gray.shape[1]-yWin,int((yWin-1)/2)):
  
  for m in range(he1_gray.shape[0]-xWin):
    if m+xWin > he1_gray.shape[0] :
          break
    for n in range(he1_gray.shape[1]-yWin):

       

        he1_local = he1_gray[m:m+xWin,n:n+yWin]

        unique, counts = np.unique(he1_local, return_counts=True)
        
      # count of each pixel 
        dict_he1 =dict(zip(unique, counts))

      # sum of all pixels
        sum_he1 = sum(dict_he1.values())

        # preprocessing
        if dict_he1.get(0)==None:
            dict_he1[0]=0

        # count of each pixel / sum of all pixels
        for i in dict_he1 :
              dict_he1[i] = dict_he1[i] / sum_he1
          
        dict_accum = {}
        dict_accum[0] = dict_he1.get(0)
        
        # cumulative sum 
        for i in range(1,256):
            if dict_he1.get(i):
              dict_accum[i] =  dict_he1.get(i) + dict_accum.get(i-1)
            else:
              dict_accum[i]= dict_accum.get(i-1)

        # cumulative sum * max of pixels range
        for i in range(256):
              dict_accum[i] = round(dict_accum.get(i)*255)

        #  equalize image
        for i in range(he1_local.shape[0]):
            for j in range(he1_local.shape[1]):
              he1_gray[i+m][j+n] = dict_accum[he1_local[i][j]]
  cv2_imshow(he1_gray)
  # return he1_gray
  
LHE(he1,201,201)

